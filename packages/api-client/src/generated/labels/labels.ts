/**
 * Generated by orval v7.17.2 üç∫
 * Do not edit manually.
 * Vikunja API
 * # Pagination
Every endpoint capable of pagination will return two headers:
* `x-pagination-total-pages`: The total number of available pages for this request
* `x-pagination-result-count`: The number of items returned for this request.
# Permissions
All endpoints which return a single item (project, task, etc.) - no array - will also return a `x-max-permission` header with the max permission the user has on this item as an int where `0` is `Read Only`, `1` is `Read & Write` and `2` is `Admin`.
This can be used to show or hide ui elements based on the permissions the user has.
# Errors
All errors have an error code and a human-readable error message in addition to the http status code. You should always check for the status code in the response, not only the http status code.
Due to limitations in the swagger library we're using for this document, only one error per http status code is documented here. Make sure to check the [error docs](https://vikunja.io/docs/errors/) in Vikunja's documentation for a full list of available error codes.
# Authorization
**JWT-Auth:** Main authorization method, used for most of the requests. Needs `Authorization: Bearer <jwt-token>`-header to authenticate successfully.

**API Token:** You can create scoped API tokens for your user and use the token to make authenticated requests in the context of that user. The token must be provided via an `Authorization: Bearer <token>` header, similar to jwt auth. See the documentation for the `api` group to manage token creation and revocation.

**BasicAuth:** Only used when requesting tasks via CalDAV.
<!-- ReDoc-Inject: <security-definitions> -->
 * OpenAPI spec version: 0.24.0
 */
import type {
  GetLabelsParams,
  GetTasksTaskLabelsParams,
  ModelsLabel,
  ModelsLabelBody,
  ModelsLabelTask,
  ModelsLabelTaskBulk,
  ModelsMessage
} from '.././model';

import { customInstance } from '../../lib/axios-instance';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];


  /**
 * Returns all labels which are either created by the user or associated with a task the user has at least read-access to.
 * @summary Get all labels a user has access to
 */
export const getLabels = (
    params?: GetLabelsParams,
 options?: SecondParameter<typeof customInstance<ModelsLabel[]>>,) => {
      return customInstance<ModelsLabel[]>(
      {url: `/labels`, method: 'GET',
        params
    },
      options);
    }
  /**
 * Creates a new label.
 * @summary Create a label
 */
export const putLabels = (
    modelsLabelBody: ModelsLabelBody,
 options?: SecondParameter<typeof customInstance<ModelsLabel>>,) => {
      return customInstance<ModelsLabel>(
      {url: `/labels`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: modelsLabelBody
    },
      options);
    }
  /**
 * Delete an existing label. The user needs to be the creator of the label to be able to do this.
 * @summary Delete a label
 */
export const deleteLabelsId = (
    id: number,
 options?: SecondParameter<typeof customInstance<ModelsLabel>>,) => {
      return customInstance<ModelsLabel>(
      {url: `/labels/${id}`, method: 'DELETE'
    },
      options);
    }
  /**
 * Returns one label by its ID.
 * @summary Gets one label
 */
export const getLabelsId = (
    id: number,
 options?: SecondParameter<typeof customInstance<ModelsLabel>>,) => {
      return customInstance<ModelsLabel>(
      {url: `/labels/${id}`, method: 'GET'
    },
      options);
    }
  /**
 * Update an existing label. The user needs to be the creator of the label to be able to do this.
 * @summary Update a label
 */
export const putLabelsId = (
    id: number,
    modelsLabelBody: ModelsLabelBody,
 options?: SecondParameter<typeof customInstance<ModelsLabel>>,) => {
      return customInstance<ModelsLabel>(
      {url: `/labels/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: modelsLabelBody
    },
      options);
    }
  /**
 * Returns all labels which are assicociated with a given task.
 * @summary Get all labels on a task
 */
export const getTasksTaskLabels = (
    task: number,
    params?: GetTasksTaskLabelsParams,
 options?: SecondParameter<typeof customInstance<ModelsLabel[]>>,) => {
      return customInstance<ModelsLabel[]>(
      {url: `/tasks/${task}/labels`, method: 'GET',
        params
    },
      options);
    }
  /**
 * Add a label to a task. The user needs to have write-access to the project to be able do this.
 * @summary Add a label to a task
 */
export const putTasksTaskLabels = (
    task: number,
    modelsLabelTask: ModelsLabelTask,
 options?: SecondParameter<typeof customInstance<ModelsLabelTask>>,) => {
      return customInstance<ModelsLabelTask>(
      {url: `/tasks/${task}/labels`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: modelsLabelTask
    },
      options);
    }
  /**
 * Remove a label from a task. The user needs to have write-access to the project to be able do this.
 * @summary Remove a label from a task
 */
export const deleteTasksTaskLabelsLabel = (
    task: number,
    label: number,
 options?: SecondParameter<typeof customInstance<ModelsMessage>>,) => {
      return customInstance<ModelsMessage>(
      {url: `/tasks/${task}/labels/${label}`, method: 'DELETE'
    },
      options);
    }
  /**
 * Updates all labels on a task. Every label which is not passed but exists on the task will be deleted. Every label which does not exist on the task will be added. All labels which are passed and already exist on the task won't be touched.
 * @summary Update all labels on a task.
 */
export const postTasksTaskIDLabelsBulk = (
    taskID: number,
    modelsLabelTaskBulk: ModelsLabelTaskBulk,
 options?: SecondParameter<typeof customInstance<ModelsLabelTaskBulk>>,) => {
      return customInstance<ModelsLabelTaskBulk>(
      {url: `/tasks/${taskID}/labels/bulk`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: modelsLabelTaskBulk
    },
      options);
    }
  
type AwaitedInput<T> = PromiseLike<T> | T;

    type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;

export type GetLabelsResult = NonNullable<Awaited<ReturnType<typeof getLabels>>>
export type PutLabelsResult = NonNullable<Awaited<ReturnType<typeof putLabels>>>
export type DeleteLabelsIdResult = NonNullable<Awaited<ReturnType<typeof deleteLabelsId>>>
export type GetLabelsIdResult = NonNullable<Awaited<ReturnType<typeof getLabelsId>>>
export type PutLabelsIdResult = NonNullable<Awaited<ReturnType<typeof putLabelsId>>>
export type GetTasksTaskLabelsResult = NonNullable<Awaited<ReturnType<typeof getTasksTaskLabels>>>
export type PutTasksTaskLabelsResult = NonNullable<Awaited<ReturnType<typeof putTasksTaskLabels>>>
export type DeleteTasksTaskLabelsLabelResult = NonNullable<Awaited<ReturnType<typeof deleteTasksTaskLabelsLabel>>>
export type PostTasksTaskIDLabelsBulkResult = NonNullable<Awaited<ReturnType<typeof postTasksTaskIDLabelsBulk>>>
